---
layout:     post
title:      了解runtime运行时机制
category: blog
description: runtime是纯c语言的api，平常编写的OC代码，在程序的运行过程中，最终都会转化成runtime的c语言代码。利用runtime主要是做一些底层的操作
---
runtime是纯c语言的api，平常编写的OC代码，在程序的运行过程中，最终都会转化成runtime的c语言代码。利用runtime主要是做一些底层的操作，比如：
> 动态添加对象的成员变量和方法（可以给分类添加属性）
动态交换两个方法的实现（可以替换系统的方法）
获得某个类的所有成员方法，所有成员变量
实现NSCoding的自动归档和解档
实现字典转模型的自动转换

* 有时想动态的给类添加一个属性，或者想给分类添加属性，这样就可以使用运行时来添加：
在.h文件添加属性

```
@property (nonatomic, copy) NSString *name;
```

在.m文件中实现setter、getter方法：

```
static NSString *nameKey;

 - (void)setName:(NSString *)name {
    objc_setAssociatedObject(self, &nameKey, name, OBJC_ASSOCIATION_COPY);
}

 - (NSString *)name {
    return objc_getAssociatedObject(self, &nameKey);
}
```

* 想要获取类中的所有的属性和其类型，也可以使用运行时来实现：

```
 @interface Person : NSObject

 @property (nonatomic, assign) int age;

 @property (nonatomic, copy) NSString *place;

 @end
```

在想要获取的方法中：

```
unsigned int outCount = 0;
        Ivar *ivars = class_copyIvarList([Person class], &outCount);
        for (int i = 0; i < outCount; i++) {
            Ivar ivar = ivars[i];
            const char *name = ivar_getName(ivar);
            const char *type = ivar_getTypeEncoding(ivar);
        }
```

* 可以交换类中的两个方法：
 比如定义一个Person类
  Person头文件
  
```
 @interface Person : NSObject

 - (void)eat;

 - (void)sleep;

 @end
```

Person实现代码

```
 @implementation Person

 - (void)eat {
    NSLog(@"eat");
}

 - (void)sleep {
    NSLog(@"sleep");
}

 @end
```

在需要交换的地方使用运行时：

```
Method eat = class_getInstanceMethod([Person class], @selector(eat));
Method sleep = class_getInstanceMethod([Person class], @selector(sleep));
method_exchangeImplementations(eat, sleep);
Person *person = [[Person alloc] init];
[person eat];
[person sleep];
```

输出结果

```
2016-03-17 23:23:55.713 runtime[2057:63207] sleep
2016-03-17 23:23:55.713 runtime[2057:63207] eat
```